// Generated by CoffeeScript 1.10.0
(function() {
  var Cryptography, Immutable, JSONfromHTTPRequest, Kijiji, addInstrument, compile, echo, exec, files, identifyInstrumentAddress, indexHTML, initialize, instruments, memorize, mime, parallel, read, send, sendBinary, sendScript, service, watch, write;

  JSONfromHTTPRequest = require("body/json");

  Cryptography = require('crypto');

  Immutable = require('immutable');

  files = require("facts")();

  instruments = require("facts")();

  instruments.datoms = Immutable.Stack(Immutable.fromJS(require("./instruments.datoms.json")));

  console.info(instruments.query());

  instruments.on("transaction", function() {
    return write("instruments.datoms.json", JSON.stringify(instruments.datoms, void 0, "  "), "UTF-8", function(error) {
      if (error) {
        console.error(error);
      }
      return console.info("Wrote instruments.datoms.json to file system");
    });
  });

  service = require("http").createServer(function(request, response) {
    var database, identifier, out, outputBuffer, serialized;
    console.info({
      request: identifier = decodeURIComponent(request.url.replace("/", ""))
    });
    switch (false) {
      case request.method !== "POST":
        return JSONfromHTTPRequest(request, function(error, data) {
          console.info({
            post: data
          });
          return addInstrument(data.location);
        });
      case identifier !== "database.json":
        database = instruments.database();
        serialized = JSON.stringify(database, void 0, "  ");
        outputBuffer = new Buffer(serialized, "UTF-8");
        send(response, out = {
          file: "database.json",
          type: "application/json; charset=UTF-8",
          size: outputBuffer.length,
          data: outputBuffer
        });
        return write("database.json", serialized, "UTF8");
      case identifier !== "":
        return indexHTML(function(error, HTML) {
          var output;
          if (error) {
            throw error;
          }
          send(response, output = {
            file: "index.html",
            type: "text/html; charset=UTF-8",
            size: HTML.length,
            data: HTML
          });
          return write("index.html", HTML, "UTF8");
        });
      case !/js/.test(identifier):
        return sendScript(identifier, response);
      case !/png|jpg|svg|woff/.test(identifier):
        return sendBinary(identifier, response);
      default:
        console.error({
          unhandled: identifier
        });
        response.writeHead(404, {
          "Content-Length": 0
        });
        return response.end();
    }
  });

  service.listen(8080, function(error) {
    if (error) {
      throw error;
    }
    return console.info({
      listening: service.address()
    });
  });

  addInstrument = function(location, callback) {
    switch (false) {
      case !location.match("kijiji"):
        return addInstrument.fromKijiji(location, callback);
      default:
        throw "unknown instrument host";
    }
  };

  Kijiji = require("./kijiji");

  addInstrument.fromKijiji = function(location, callback) {
    return Kijiji.read(location, function(error, output) {
      var address, identifier;
      if (error) {
        throw error;
      }
      address = output.address;
      identifier = identifyInstrumentAddress(address);
      instruments.advance(identifier, output);
      return console.info({
        identifier: output
      });
    });
  };

  identifyInstrumentAddress = function(address) {
    var hash;
    hash = Cryptography.createHash('sha256');
    hash.update(address);
    return hash.digest('hex');
  };

  indexHTML = function(callback) {
    return callback(void 0, "<!DOCTYPE HTML>\n<meta charset=\"UTF-8\">\n<title>Lefty Guitars For Sale Under $1000</title>\n<script src=\"d3.min.js\" charset=\"UTF-8\"></script>\n<script src=\"Facts.pack.js\" charset=\"UTF-8\"></script>\n<script src=\"document.js\" charset=\"UTF-8\"></script>\n<script src=\"index.js\" charset=\"UTF-8\"></script>");
  };

  sendScript = function(identifier, response) {
    var out, script;
    if (script = files.pull(identifier)) {
      return send(response, out = {
        file: identifier,
        type: "application/ecmascript; charset=UTF-8",
        size: script.size,
        data: script.data
      });
    } else {
      return initialize(identifier, function() {
        return sendScript(identifier, response);
      });
    }
  };

  sendBinary = function(identifier, response) {
    return read(identifier, function(error, data) {
      var output;
      if (error) {
        throw error;
      } else {
        return send(response, output = {
          file: identifier,
          type: mime.lookup(identifier),
          size: data.length,
          data: data
        });
      }
    });
  };

  send = function(response, output) {
    response.writeHead(200, {
      "Content-Length": output.size,
      "Content-Type": output.type
    });
    response.end(output.data);
    return console.info({
      "send": {
        file: output.file,
        type: output.type,
        size: output.size,
        data: output.data.constructor.name
      }
    });
  };

  initialize = function(identifier, done) {
    if (files.pull(identifier) === void 0) {
      watch(identifier, function(event) {
        if (event === "change") {
          return memorize(identifier);
        }
      });
      console.info({
        watching: identifier
      });
      return memorize(identifier, done);
    } else {
      return done();
    }
  };

  memorize = function(identifier, done) {
    return read(identifier, function(error, data) {
      files.advance(identifier, {
        size: data.length,
        data: data.toString("UTF-8")
      });
      console.info({
        memorized: identifier
      });
      if (done) {
        return done();
      }
    });
  };

  compile = require("coffee-script").compile;

  echo = function(identifier) {
    return files.pull(identifier).data;
  };

  exec = require("child_process").exec;

  mime = require("mime");

  parallel = require("async").parallel;

  read = require("fs").readFile;

  watch = require("fs").watch;

  write = require("fs").writeFile;

}).call(this);
